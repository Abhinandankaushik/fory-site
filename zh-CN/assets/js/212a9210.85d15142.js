"use strict";(self.webpackChunkfory_site=self.webpackChunkfory_site||[]).push([[5924],{34999:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>s,metadata:()=>a,toc:()=>c});var i=r(85893),t=r(11151);const s={title:"Basic Serialization",sidebar_position:2,id:"basic_serialization",license:'Licensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the "License"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an "AS IS" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n'},o=void 0,a={id:"guide/cpp/basic_serialization",title:"Basic Serialization",description:"This page covers basic object graph serialization and the core serialization APIs.",source:"@site/i18n/zh-CN/docusaurus-plugin-content-docs/current/guide/cpp/basic-serialization.md",sourceDirName:"guide/cpp",slug:"/guide/cpp/basic_serialization",permalink:"/zh-CN/docs/next/guide/cpp/basic_serialization",draft:!1,unlisted:!1,editUrl:"https://github.com/apache/fory-site/tree/main/i18n/zh-CN/docusaurus-plugin-content-docs/current/guide/cpp/basic-serialization.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"Basic Serialization",sidebar_position:2,id:"basic_serialization",license:'Licensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the "License"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an "AS IS" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n'},sidebar:"docsSidebar",previous:{title:"Configuration",permalink:"/zh-CN/docs/next/guide/cpp/configuration"},next:{title:"Schema Evolution",permalink:"/zh-CN/docs/next/guide/cpp/schema_evolution"}},l={},c=[{value:"Object Graph Serialization",id:"object-graph-serialization",level:2},{value:"Serialization APIs",id:"serialization-apis",level:2},{value:"Serialize to New Vector",id:"serialize-to-new-vector",level:3},{value:"Serialize to Existing Buffer",id:"serialize-to-existing-buffer",level:3},{value:"Deserialize from Byte Array",id:"deserialize-from-byte-array",level:3},{value:"Error Handling",id:"error-handling",level:2},{value:"The FORY_STRUCT Macro",id:"the-fory_struct-macro",level:2},{value:"Nested Structs",id:"nested-structs",level:2},{value:"Performance Tips",id:"performance-tips",level:2},{value:"Related Topics",id:"related-topics",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"This page covers basic object graph serialization and the core serialization APIs."}),"\n",(0,i.jsx)(n.h2,{id:"object-graph-serialization",children:"Object Graph Serialization"}),"\n",(0,i.jsxs)(n.p,{children:["Apache Fory\u2122 provides automatic serialization of complex object graphs, preserving the structure and relationships between objects. The ",(0,i.jsx)(n.code,{children:"FORY_STRUCT"})," macro generates efficient serialization code at compile time, eliminating runtime overhead."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Key capabilities:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Nested struct serialization with arbitrary depth"}),"\n",(0,i.jsx)(n.li,{children:"Collection types (vector, set, map)"}),"\n",(0,i.jsxs)(n.li,{children:["Optional fields with ",(0,i.jsx)(n.code,{children:"std::optional<T>"})]}),"\n",(0,i.jsxs)(n.li,{children:["Smart pointers (",(0,i.jsx)(n.code,{children:"std::shared_ptr"}),", ",(0,i.jsx)(n.code,{children:"std::unique_ptr"}),")"]}),"\n",(0,i.jsx)(n.li,{children:"Automatic handling of primitive types and strings"}),"\n",(0,i.jsx)(n.li,{children:"Efficient binary encoding with variable-length integers"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'#include "fory/serialization/fory.h"\n#include <vector>\n#include <map>\n\nusing namespace fory::serialization;\n\n// Define structs\nstruct Address {\n  std::string street;\n  std::string city;\n  std::string country;\n\n  bool operator==(const Address &other) const {\n    return street == other.street && city == other.city &&\n           country == other.country;\n  }\n};\nFORY_STRUCT(Address, street, city, country);\n\nstruct Person {\n  std::string name;\n  int32_t age;\n  Address address;\n  std::vector<std::string> hobbies;\n  std::map<std::string, std::string> metadata;\n\n  bool operator==(const Person &other) const {\n    return name == other.name && age == other.age &&\n           address == other.address && hobbies == other.hobbies &&\n           metadata == other.metadata;\n  }\n};\nFORY_STRUCT(Person, name, age, address, hobbies, metadata);\n\nint main() {\n  auto fory = Fory::builder().xlang(true).build();\n  fory.register_struct<Address>(100);\n  fory.register_struct<Person>(200);\n\n  Person person{\n      "John Doe",\n      30,\n      {"123 Main St", "New York", "USA"},\n      {"reading", "coding"},\n      {{"role", "developer"}}\n  };\n\n  auto result = fory.serialize(person);\n  auto decoded = fory.deserialize<Person>(result.value());\n  assert(person == decoded.value());\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"serialization-apis",children:"Serialization APIs"}),"\n",(0,i.jsx)(n.h3,{id:"serialize-to-new-vector",children:"Serialize to New Vector"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"auto fory = Fory::builder().xlang(true).build();\nfory.register_struct<MyStruct>(1);\n\nMyStruct obj{/* ... */};\n\n// Serialize - returns Result<std::vector<uint8_t>, Error>\nauto result = fory.serialize(obj);\nif (result.ok()) {\n  std::vector<uint8_t> bytes = std::move(result).value();\n  // Use bytes...\n} else {\n  // Handle error\n  std::cerr << result.error().to_string() << std::endl;\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"serialize-to-existing-buffer",children:"Serialize to Existing Buffer"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"// Serialize to existing Buffer (fastest path)\nBuffer buffer;\nauto result = fory.serialize_to(buffer, obj);\nif (result.ok()) {\n  size_t bytes_written = result.value();\n  // buffer now contains serialized data\n}\n\n// Serialize to existing vector (zero-copy)\nstd::vector<uint8_t> output;\nauto result = fory.serialize_to(output, obj);\nif (result.ok()) {\n  size_t bytes_written = result.value();\n  // output now contains serialized data\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"deserialize-from-byte-array",children:"Deserialize from Byte Array"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"// Deserialize from raw pointer\nauto result = fory.deserialize<MyStruct>(data_ptr, data_size);\nif (result.ok()) {\n  MyStruct obj = std::move(result).value();\n}\n\n// Deserialize from vector\nstd::vector<uint8_t> data = /* ... */;\nauto result = fory.deserialize<MyStruct>(data);\n\n// Deserialize from Buffer (updates reader_index)\nBuffer buffer(data);\nauto result = fory.deserialize<MyStruct>(buffer);\n"})}),"\n",(0,i.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,i.jsxs)(n.p,{children:["Fory uses a ",(0,i.jsx)(n.code,{children:"Result<T, Error>"})," type for error handling:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'auto result = fory.serialize(obj);\n\n// Check if operation succeeded\nif (result.ok()) {\n  auto value = std::move(result).value();\n  // Use value...\n} else {\n  Error error = result.error();\n  std::cerr << "Error: " << error.to_string() << std::endl;\n}\n\n// Or use FORY_TRY macro for early return\nFORY_TRY(bytes, fory.serialize(obj));\n// Use bytes directly...\n'})}),"\n",(0,i.jsx)(n.p,{children:"Common error types:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Error::type_mismatch"})," - Type ID mismatch during deserialization"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Error::invalid_data"})," - Invalid or corrupted data"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Error::buffer_out_of_bound"})," - Buffer overflow/underflow"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Error::type_error"})," - Type registration error"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"the-fory_struct-macro",children:"The FORY_STRUCT Macro"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"FORY_STRUCT"})," macro registers a struct for serialization:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"struct MyStruct {\n  int32_t x;\n  std::string y;\n  std::vector<int32_t> z;\n};\n\n// Must be in the same namespace as the struct\nFORY_STRUCT(MyStruct, x, y, z);\n"})}),"\n",(0,i.jsx)(n.p,{children:"The macro:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Generates compile-time field metadata"}),"\n",(0,i.jsx)(n.li,{children:"Enables ADL (Argument-Dependent Lookup) for serialization"}),"\n",(0,i.jsx)(n.li,{children:"Creates efficient serialization code via template specialization"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Requirements:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Must be placed in the same namespace as the struct (for ADL)"}),"\n",(0,i.jsx)(n.li,{children:"All listed fields must be serializable types"}),"\n",(0,i.jsx)(n.li,{children:"Field order in the macro determines serialization order"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"nested-structs",children:"Nested Structs"}),"\n",(0,i.jsx)(n.p,{children:"Nested structs are fully supported:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"struct Inner {\n  int32_t value;\n};\nFORY_STRUCT(Inner, value);\n\nstruct Outer {\n  Inner inner;\n  std::string label;\n};\nFORY_STRUCT(Outer, inner, label);\n\n// Both must be registered\nfory.register_struct<Inner>(1);\nfory.register_struct<Outer>(2);\n"})}),"\n",(0,i.jsx)(n.h2,{id:"performance-tips",children:"Performance Tips"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Buffer Reuse"}),": Use ",(0,i.jsx)(n.code,{children:"serialize_to(buffer, obj)"})," with pre-allocated buffers"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Pre-registration"}),": Register all types before serialization starts"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Single-Threaded"}),": Use ",(0,i.jsx)(n.code,{children:"build()"})," instead of ",(0,i.jsx)(n.code,{children:"build_thread_safe()"})," when possible"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Disable Tracking"}),": Use ",(0,i.jsx)(n.code,{children:"track_ref(false)"})," when references aren't needed"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Compact Encoding"}),": Variable-length encoding for space efficiency"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"related-topics",children:"Related Topics"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/zh-CN/docs/next/guide/cpp/configuration",children:"Configuration"})," - Builder options"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/zh-CN/docs/next/guide/cpp/type_registration",children:"Type Registration"})," - Registering types"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/zh-CN/docs/next/guide/cpp/supported_types",children:"Supported Types"})," - All supported types"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},11151:(e,n,r)=>{r.d(n,{Z:()=>a,a:()=>o});var i=r(67294);const t={},s=i.createContext(t);function o(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);